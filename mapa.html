<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <title>Mapa T√°ctico - Sniffer Mesh con Trayectoria</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        :root {
            --bg: #0f172a;
            --panel: #1e293b;
            --accent: #38bdf8;
        }

        body {
            margin: 0;
            padding: 0;
            background: var(--bg);
            font-family: 'Segoe UI', sans-serif;
            color: white;
        }

        #map {
            height: 100vh;
            width: 100%;
        }

        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(30, 41, 59, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--accent);
            width: 350px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            max-height: 90vh;
            display: flex;
            flex-direction: column;
        }

        .legend {
            font-size: 11px;
            margin-top: 10px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }

        .node-label {
            background: transparent;
            border: none;
            color: #38bdf8;
            font-weight: bold;
            font-size: 12px;
            text-shadow: 1px 1px 2px black;
        }

        /* Estilo para tabla de selecci√≥n */
        .device-list {
            flex: 1;
            overflow-y: auto;
            margin: 10px 0;
            border: 1px solid #334155;
            border-radius: 4px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }

        th {
            position: sticky;
            top: 0;
            background: #334155;
            padding: 5px;
            text-align: left;
            font-size: 0.75rem;
        }

        td {
            padding: 5px;
            border-bottom: 1px solid #334155;
        }

        tr:hover {
            background: #2d3a4f;
        }

        input[type="checkbox"] {
            accent-color: var(--accent);
            cursor: pointer;
        }

        .btn {
            width: 100%;
            padding: 8px;
            background: var(--accent);
            border: none;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            color: #0f172a;
            margin-top: 5px;
        }

        .btn:hover {
            opacity: 0.9;
        }
    </style>
</head>

<body>

    <div class="info-panel">
        <h3 style="margin:0 0 5px 0; color:var(--accent);">üõ∞Ô∏è Tracking T√°ctico</h3>
        <div id="status" style="font-size: 0.85rem; color: #94a3b8;">Sistema Listo</div>

        <div class="device-list">
            <table>
                <thead>
                    <tr>
                        <th width="30">Ver</th>
                        <th>MAC / Vendor</th>
                        <th>Visto</th>
                    </tr>
                </thead>
                <tbody id="macTableBody">
                    <tr>
                        <td colspan="3" style="text-align:center">Cargando...</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="legend">
            <div style="color:#ef4444">‚óè Nodo Mesh</div>
            <div style="color:#f59e0b">‚óè Nodo Standalone</div>
            <div style="color:#94a3b8">‚óè Nodo Offline (>120s)</div>
            <div style="color:#22c55e">‚óè Objetivo</div>
            <div style="color:#6366f1">--- Trayectoria</div>
        </div>

        <!-- Section for manual MAC filtering -->
        <div style="margin-top:15px; border-top:1px solid #334155; padding-top:10px;">
            <label style="font-size:0.75rem; color:#94a3b8; display:block; margin-bottom:5px;">RASTREO MANUAL</label>
            <div style="display:flex; gap:5px;">
                <input type="text" id="manualMacInput" placeholder="MAC Address (AA:BB:CC...)"
                    style="background:#0f172a; border:1px solid #334155; color:white; padding:5px; border-radius:4px; flex:1; font-size:0.8rem;">
                <button onclick="applyManualFilter()"
                    style="background:#38bdf8; color:#0f172a; border:none; border-radius:4px; font-weight:bold; cursor:pointer;"
                    title="Rastrear">üéØ</button>
                <button onclick="clearManualFilter()"
                    style="background:#ef4444; color:white; border:none; border-radius:4px; font-weight:bold; cursor:pointer;"
                    title="Borrar / Dejar de Rastrear">üóëÔ∏è</button>
            </div>
        </div>

        <button onclick="window.location.href='index.html'" class="btn"
            style="background:#475569; color:white; margin-top:20px;">VOLVER AL DASHBOARD</button>
    </div>

    <div id="map"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // ---------------------------------------------------------
        // 1. CONSTANTES Y CONFIGURACI√ìN
        // ---------------------------------------------------------
        // Configuraci√≥n de visualizaci√≥n
        const RSSI_AT_1M = -40;
        const N_ENV = 2.5;

        // Mapa base ( Leaflet )
        const map = L.map('map', {
            zoomControl: false,
            maxZoom: 25
        }).setView([-34.3382, -56.7055], 18);

        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; CartoDB',
            maxNativeZoom: 19,
            maxZoom: 25
        }).addTo(map);

        const nodesInMap = {}; // Diccionario de capas Leaflet por ID de nodo
        const trackingSujetos = {};
        const kalmanFilters = {};

        // ---------------------------------------------------------
        // 2. MATEM√ÅTICAS MEJORADAS (Trilateraci√≥n Real)
        // ---------------------------------------------------------

        class KalmanFilter {
            constructor(R = 1, Q = 1, A = 1, B = 0, C = 1) {
                this.R = R; // Ruido medida
                this.Q = Q; // Ruido proceso
                this.A = A; this.B = B; this.C = C;
                this.cov = NaN; this.x = NaN;
            }
            filter(measurement) {
                if (isNaN(this.x)) {
                    this.x = measurement;
                    this.cov = this.R;
                } else {
                    const predX = this.x;
                    const predCov = this.cov + this.Q;
                    const K = predCov * this.C * (1 / (predCov + this.R));
                    this.x = predX + K * (measurement - predX);
                    this.cov = predCov - (K * predCov);
                }
                return this.x;
            }
        }

        function rssiToMeters(rssi) {
            // d = 10 ^ ((RSSI_0 - RSSI) / (10 * n))
            // Limitamos RSSI m√≠nimo para evitar distancias astron√≥micas
            const r = Math.max(rssi, -95);
            return Math.pow(10, (RSSI_AT_1M - r) / (10 * N_ENV));
        }

        function resolverPosicion(nodosActivos) {
            if (nodosActivos.length === 0) return null;

            // Si solo un nodo ve al sujeto, usar c√≠rculo de incertidumbre
            // Devolvemos un punto aleatorio EN EL RADIO calculado para simular √°rea
            if (nodosActivos.length === 1) {
                const n = nodosActivos[0];
                const angulo = Math.random() * 2 * Math.PI;
                // Convertir metros a grados (aprox en latitud -34)
                const degLat = n.dist / 111111;
                const degLng = n.dist / (111111 * Math.cos(-34.33 * Math.PI / 180));

                return [
                    n.lat + (degLat * Math.sin(angulo)),
                    n.lng + (degLng * Math.cos(angulo))
                ];
            }

            // Trilateraci√≥n Multilaterada (M√≠nimos Cuadrados)
            // Buscamos (x,y) tal que minimice Œ£(sqrt((x-xi)¬≤+(y-yi)¬≤) - di)¬≤

            // Estimaci√≥n inicial: Centroide (media)
            let x = 0, y = 0;
            nodosActivos.forEach(n => { x += n.lat; y += n.lng; });
            x /= nodosActivos.length;
            y /= nodosActivos.length;

            // Gradient Descent
            const alpha = 0.0000005; // Learning rate (ajustado p/ grados)
            const metersPerDegLat = 111111;
            const metersPerDegLng = 111111 * Math.cos(-34.33 * Math.PI / 180); // ~91800m

            for (let i = 0; i < 100; i++) {
                let gradX = 0, gradY = 0;

                nodosActivos.forEach(n => {
                    // Distancia actual en metros (convertida de grados diff)
                    const dx_deg = x - n.lat;
                    const dy_deg = y - n.lng;

                    const dx_m = dx_deg * metersPerDegLat;
                    const dy_m = dy_deg * metersPerDegLng;

                    const dist_calc = Math.sqrt(dx_m * dx_m + dy_m * dy_m);
                    const dist_real = n.dist;

                    const error = dist_calc - dist_real;

                    // Derivadas parciales
                    if (dist_calc > 0.1) { // Evitar div/0
                        gradX += error * (dx_m / dist_calc) * metersPerDegLat;
                        gradY += error * (dy_m / dist_calc) * metersPerDegLng;
                    }
                });

                // Normalizar gradiente si es muy grande (evitar saltos locos)
                // Esto es crucial para la estabilidad
                x -= alpha * gradX;
                y -= alpha * gradY;
            }

            return [x, y];
        }

        // ---------------------------------------------------------
        // 3. NODE MANAGEMENT (DIN√ÅMICO & PERSISTENTE)
        // ---------------------------------------------------------
        async function loadNodes() {
            try {
                const res = await fetch('/api/nodes');
                const nodes = await res.json();

                nodes.forEach(n => {
                    const id = n.id;
                    const pos = [n.lat, n.lng];
                    const diffS = (new Date() - new Date(n.last_seen)) / 1000;

                    // MAP-03: Diferenciaci√≥n Visual & MAP-04: Watchdog
                    let color = (n.type === 'standalone') ? '#f59e0b' : '#ef4444';
                    if (diffS > 120) color = '#94a3b8'; // Offline

                    if (!nodesInMap[id]) {
                        // Crear Capas (C√≠rculos y Marker Draggable)
                        const range = L.circle(pos, { color: color, radius: 20, weight: 1, fill: false, dashArray: '4,4', opacity: 0.3 }).addTo(map);
                        const center = L.circle(pos, { color: color, radius: 1.5, fillOpacity: 0.8 }).addTo(map);

                        // MAP-01: Marcadores Arrastrables
                        const marker = L.marker(pos, {
                            draggable: true,
                            icon: L.divIcon({
                                className: 'node-label',
                                html: `<span style="color:${color}">${id}</span>`,
                                iconAnchor: [15, -5]
                            })
                        }).addTo(map);

                        // MAP-02: Persistencia al arrastrar
                        marker.on('dragend', async function (event) {
                            const newPos = event.target.getLatLng();
                            if (confirm(`¬øDesea confirmar la nueva ubicaci√≥n del nodo ${id}?`)) {
                                try {
                                    const updateRes = await fetch('/api/nodes', {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ id, lat: newPos.lat, lng: newPos.lng })
                                    });
                                    if (updateRes.ok) {
                                        range.setLatLng(newPos);
                                        center.setLatLng(newPos);
                                        console.log(`Ubicaci√≥n de ${id} actualizada.`);
                                    }
                                } catch (e) { alert("Error guardando ubicaci√≥n."); }
                            } else {
                                // Revertir si cancela
                                marker.setLatLng(pos);
                            }
                        });

                        nodesInMap[id] = { range, center, marker, data: n };
                    } else {
                        // Actualizar existentes
                        nodesInMap[id].data = n;
                        nodesInMap[id].range.setStyle({ color: color });
                        nodesInMap[id].center.setStyle({ color: color });
                        nodesInMap[id].marker.setIcon(L.divIcon({
                            className: 'node-label',
                            html: `<span style="color:${color}">${id}</span>`,
                            iconAnchor: [15, -5]
                        }));
                    }
                });
            } catch (e) { console.error("Error cargando nodos:", e); }
        }

        // Refresco del Watchdog cada 10s
        setInterval(loadNodes, 10000);

        // ---------------------------------------------------------
        // 3. APP LOGIC
        // ---------------------------------------------------------

        async function cargarMACs() {
            try {
                const res = await fetch('/api/macs');
                const macs = await res.json();
                const tbody = document.getElementById('macTableBody');
                tbody.innerHTML = '';

                macs.forEach(m => {
                    const tr = document.createElement('tr');
                    const timeStr = timeSince(new Date(m.last_seen));
                    tr.innerHTML = `
                    <td style="text-align:center"><input type="checkbox" onchange="toggleMac('${m.mac}', this.checked)"></td>
                    <td>
                        <strong style="color:#38bdf8">${m.mac}</strong><br>
                        <span style="color:#94a3b8; font-size:0.75em">${m.vendor || 'Unknown'}</span>
                    </td>
                    <td style="font-size:0.75em; color:#cbd5e1">${timeStr}</td>
                `;
                    tbody.appendChild(tr);
                });
            } catch (e) {
                console.error(e);
                document.getElementById('status').innerText = "Error cargando lista.";
            }
        }

        async function toggleMac(mac, active) {
            if (!active) {
                if (trackingSujetos[mac]) {
                    map.removeLayer(trackingSujetos[mac].marker);
                    map.removeLayer(trackingSujetos[mac].path);
                    delete trackingSujetos[mac];
                }
                if (kalmanFilters[mac]) delete kalmanFilters[mac];
                return;
            }

            document.getElementById('status').innerText = `Procesando ${mac}...`;
            kalmanFilters[mac] = {};
            // Inicializar filtros Kalman basados en nodos conocidos actualmente en el mapa
            Object.keys(nodesInMap).forEach(nid => {
                kalmanFilters[mac][nid] = new KalmanFilter(5, 5); // R=5, Q=5 (M√°s din√°mico)
            });

            try {
                const res = await fetch(`/api/history?mac=${mac}`);
                const puntos = await res.json();

                const bloques = {};
                puntos.forEach(p => {
                    const k = Math.floor(new Date(p.created_at).getTime() / 1000);
                    if (!bloques[k]) bloques[k] = [];
                    bloques[k].push(p);
                });

                const llaves = Object.keys(bloques).sort();
                for (const k of llaves) {
                    const lecturas = bloques[k];
                    const nodosInput = [];

                    lecturas.forEach(l => {
                        const nodoId = l.nodo;
                        let kFilter = kalmanFilters[mac][nodoId];
                        if (!kFilter) {
                            kFilter = new KalmanFilter(5, 5);
                            kalmanFilters[mac][nodoId] = kFilter;
                        }
                        const rssiSuave = kFilter.filter(l.rssi);
                        const metros = rssiToMeters(rssiSuave);

                        const nData = nodesInMap[nodoId]?.data;
                        if (nData) {
                            nodosInput.push({
                                lat: nData.lat,
                                lng: nData.lng,
                                dist: metros
                            });
                        }
                    });

                    const posEstimada = resolverPosicion(nodosInput);
                    if (posEstimada) {
                        actualizarTrayectoria(mac, posEstimada, true);
                    }
                }
                document.getElementById('status').innerText = "Sistema Listo";
            } catch (e) {
                console.error(e);
            }
        }

        function actualizarTrayectoria(mac, pos, esHistorico = false) {
            if (!trackingSujetos[mac]) {
                trackingSujetos[mac] = {
                    marker: L.circleMarker(pos, { radius: 6, color: '#22c55e', fillOpacity: 1 }).addTo(map),
                    path: L.polyline([], { color: '#6366f1', weight: 2, opacity: 0.6, dashArray: '5, 10' }).addTo(map),
                    history: []
                };
                trackingSujetos[mac].marker.bindTooltip(mac, { permanent: false, direction: 'top' });
            }

            const sujeto = trackingSujetos[mac];
            sujeto.history.push(pos);
            if (!esHistorico && sujeto.history.length > 50) sujeto.history.shift();

            sujeto.marker.setLatLng(pos);
            sujeto.path.setLatLngs(sujeto.history);
            if (esHistorico) map.panTo(pos);
        }

        function timeSince(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            if (seconds < 60) return seconds + "s";
            const minutes = Math.floor(seconds / 60);
            return Math.floor(minutes / 24) + "d"; // Simplificado
        }

        function applyManualFilter() {
            const mac = document.getElementById('manualMacInput').value.trim();
            if (!mac) {
                alert("Por favor ingrese una MAC.");
                return;
            }
            toggleMac(mac, true);
        }

        function clearManualFilter() {
            const input = document.getElementById('manualMacInput');
            const mac = input.value.trim();
            if (mac) {
                toggleMac(mac, false); // Desactivar rastreo
            }
            input.value = "";
            document.getElementById('status').innerText = "Rastreo manual limpiado.";
        }

        window.onload = () => {
            loadNodes();
            cargarMACs();
        };
    </script>
</body>

</html>